{
	"nodes":[
		{"id":"65411924f6c83a84","type":"group","x":456,"y":-840,"width":2003,"height":1840,"color":"5","label":"Axios"},
		{"id":"132d663ac4b20ce3","type":"group","x":3940,"y":820,"width":290,"height":190,"color":"6","label":"token source"},
		{"id":"b64a21a1b32108ea","type":"text","text":"","x":-1234,"y":-1499,"width":250,"height":60},
		{"id":"03239d1e10d260b3","type":"text","text":"# Error Handling and token refresh\n```js\nvikorAPI.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n\n    if (error.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n      const newAccessToken = await handleTokenRefresh();\n      if (newAccessToken) {\n        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;\n        return vikorAPI(originalRequest); // Retry request with new token\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n// Token refresh logic (separated for reusability)\nconst handleTokenRefresh = async () => {\n  const refreshToken = getToken('refresh');\n  if (!refreshToken) return null;\n\n  try {\n    const response = await vikorAPI.post('/auth/renew-access-token', { refreshToken });\n    const { accessToken } = response.data;\n    setAccessToken(accessToken);\n    return accessToken;\n  } catch (error) {\n    console.error('Error refreshing access token:', error);\n    return null;\n  }\n};\n\nexport default vikorAPI;\n\n```","x":1480,"y":-235,"width":959,"height":875},
		{"id":"7ff52b1afbd864b0","type":"text","text":"# Axios setup\n```js\n// src/services/config/axios.js\nimport axios from 'axios';\nimport { getToken } from './tokenUtils';\nimport { authEndpoints, alternativeEndpoints, criteriaEndpoints } from './apiEndpoints';\n\nconst vikorAPI = axios.create({\n  baseURL: 'https://yourapi.com',\n  timeout: 10000,\n});\n```","x":476,"y":-578,"width":1963,"height":320},
		{"id":"82694394777ebb31","type":"text","text":"# Session Manager\n- **`refreshAccessToken`**: Handles refreshing the access token using the refresh token and stores the new tokens in storage.\n- **`handleTokenRefreshError`**: Clears stored tokens and redirects the user to the login page if the refresh fails (i.e., refresh token is invalid or expired).\n\n- If the refresh fails (e.g., refresh token is expired or invalid), the `authService` will handle it (log out the user and redirect to the login page).\n- This logic is centralized, so you don't need to manually check for token expiration in your components.\n-  The login, logout, and token refresh processes are managed centrally in the `authService`. \n- Your API calls will only be responsible for **requesting data** and **handling responses**, without worrying about session management.\n\n```js\n// src/services/hooks/authService.js  \n  \n// Function to handle refreshing the access token using the refresh token  \nimport {clearTokens, getToken, setAccessToken, setRefreshToken} from '../utils/token.utils.js';  \nimport vikorAPIClient from '../config/axios.js';  \nimport {useNavigate} from 'react-router-dom';  \n  \n// Function to handle the error if token refresh fails (logout)  \nexport const HandleTokenRefreshError = () => {  \n    clearTokens(); // Clear all tokens from localStorage  \n    alert('Your session has expired. Please log in again.'); // Notify user  \n    const navigate = useNavigate(); // Use `useNavigate` instead of `useHistory` in v6  \n    navigate('/login'); // Redirect to the login page  \n};\n\n```\n\n```js\nexport const refreshAccessToken = async () => {  \n    const refreshToken = getToken('refresh');  \n    if (!refreshToken) {  \n        return Promise.reject('No refresh token available');  \n    }  \n  \n    try {  \n        const response = await vikorAPIClient.post('/auth/renew-access-token', { refreshToken });  \n        const { accessToken, refreshToken: newRefreshToken } = response.data;  \n  \n        // Store the new tokens  \n        setAccessToken(accessToken);  \n        setRefreshToken(newRefreshToken);  \n  \n        return accessToken;  \n    } catch (error) {  \n        console.error('Error refreshing access token', error);  \n        HandleTokenRefreshError(); // Handle error in refreshing token (e.g., expired refresh token)  \n        return Promise.reject(error);  \n    }  \n};  \n```\n\n``refreshAccessToken`` seems redundant since we already create interceptor to do, but this used when we want manually update the access token.","x":2761,"y":-980,"width":1319,"height":1200},
		{"id":"d112876cc0a5712a","type":"text","text":"# Token management utilty\n- access and verification will be store in global state or react query caching)\n-  refresh will be store in cookies\n  \n- **`getToken`**: Retrieves a token from `localStorage` (access, refresh, or verification).\n- **`setToken`**: Saves a token to `localStorage` (access, refresh, or verification).\n- **`clearTokens`**: Clears all authentication-related tokens from `localStorage`.\n```js\n// src/services/utils/token.utils.js\n\n// Get token from localStorage (access, refresh, or verification token)\nexport const getToken = (type) => {\n  try {\n    const token = localStorage.getItem(`${type}Token`);\n    return token ? JSON.parse(token) : null;\n  } catch (error) {\n    console.error(`Error reading ${type} token from localStorage:`, error);\n    return null;\n  }\n};\n\n// Set token to localStorage (access, refresh, or verification token)\nexport const setToken = (type, token) => {\n  try {\n    localStorage.setItem(`${type}Token`, JSON.stringify(token));\n  } catch (error) {\n    console.error(`Error saving ${type} token to localStorage:`, error);\n  }\n};\n\n// Clear all stored tokens from localStorage\nexport const clearTokens = () => {\n  try {\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('verificationToken');\n  } catch (error) {\n    console.error('Error clearing tokens from localStorage:', error);\n  }\n};\n\n```","x":3080,"y":400,"width":682,"height":1020},
		{"id":"5cdb59ba0bb58f14","type":"text","text":"Memory (State) / Cache","x":3960,"y":850,"width":250,"height":60},
		{"id":"9aba57b92344336c","type":"text","text":"Cookies","x":3960,"y":930,"width":250,"height":60},
		{"id":"740c1a627b1f6030","type":"text","text":"#  Interceptor to attached any header type needed, as well as the token\n- check tokenType of all declared endpoints, if none then no need to attach authorization header\n- if it declared (access, verification, refresh) then it will be use in interceptor\n- using the same Authorization header for all three (``Authorization``: Bearer ``access`` / ``verification``/ ``refresh``)\n\n```js\n// Helper function to get the token based on the endpoint  \nconst getTokenForEndpoint = (url) => {  \n    const allEndpoints = [  \n        ...Object.values(authEndpoints),  \n        ...Object.values(alternativesEndpoints),  \n        ...Object.values(criteriaEndpoints),  \n        ...Object.values(parametersEndpoints),  \n        ...Object.values(weight_factorsEndpoints),  \n        ...Object.values(scoresEndpoints),  \n        ...Object.values(calculationEndpoints)  \n    ];  \n  \n  \n    // Loop through each endpoint object and match the url  \n    for (const { url: endpointUrl, tokenType } of allEndpoints) {  \n        // If the provided URL matches the endpoint URL  \n        if (url === endpointUrl) {  \n            if (tokenType !== 'none') {  \n                return getToken(tokenType); // Fetch token if it's not 'none'  \n            }  \n            return null; // No token needed  \n        }  \n    }  \n  \n    // If no matching endpoint is found, return null  \n    return null;  \n};  \n  \n// Add an interceptor to handle adding the Authorization header if a token is found  \nvikorAPIClient.interceptors.request.use(  \n    async (config) => {  \n        const token = getTokenForEndpoint(config.url);  \n  \n        if (token) {  \n            config.headers['Authorization'] = `Bearer ${token}`;  \n        }  \n  \n        return config;  \n    },  \n    (error) => Promise.reject(error)  \n);\n```","x":500,"y":-235,"width":944,"height":1155},
		{"id":"65130f8bddaea6a3","type":"text","text":"- The Axios interceptor will automatically attach the correct token (`access`, `refresh`, or `verification`) to the request headers based on the endpoint configuration.\n- If the access token is expired, the interceptor will automatically attempt to refresh the token using the refresh token.\n- Separates the logic for refreshing the access token to make the code more modular and reusable.","x":476,"y":-800,"width":773,"height":200},
		{"id":"1de8d33802724917","type":"text","text":"# Define all endpoint in one single source of truth\n- **Defines endpoint paths**: It organizes your API endpoints in one central place.\n- **Token type**: Each endpoint specifies what kind of token it requires (`none`, `verification`, `access`, `refresh`), which is essential for controlling access.\n```js\n//src/services/config/endpoints.js\nexport const authEndpoints = {  \n    login: { url: '/auth/login', tokenType: 'none' },  \n    register: { url: '/auth/register', tokenType: 'none' },  \n    requestVerificationToken: { url: '/auth/request-verification-token', tokenType: 'none' },  \n    verifyAccount: { url: '/auth/verify-account', tokenType: 'verification' },  \n    forgotPassword: { url: '/auth/forgot-password', tokenType: 'verification' },  \n    resetPassword: { url: '/auth/reset-password', tokenType: 'verification' },  \n    deleteAccount: { url: '/auth/delete-account', tokenType: 'access' },  \n    renewAccessToken: { url: '/auth/renew-access-token', tokenType: 'refresh' },  \n}  \n  \nexport const alternativesEndpoints = {  \n    createNewALT: { url: '/alternatives', tokenType: 'access' },  \n    getAllALT: { url: '/alternatives', tokenType: 'access' },  \n    getOneALT: { url: '/alternatives/:id_alt', tokenType: 'access' },  \n    updateOneALT: { url: '/alternatives/:id_alt', tokenType: 'access' },  \n    toggleArchiveALT: { url: '/alternatives/:id_alt/archive', tokenType: 'access' },  \n    deleteOneALT: { url: '/alternatives/:id_alt', tokenType: 'access' },  \n    getStatsALT: { url: '/alternatives/stats', tokenType: 'access' },  \n}  \n  \nexport const criteriaEndpoints = {  \n    createNewCRT: { url: '/criteria', tokenType: 'access' },  \n    getAllCRT: { url: '/criteria', tokenType: 'access' },  \n    getOneCRT: { url: '/criteria/:id_crt', tokenType: 'access' },  \n    updateOneCRT: { url: '/criteria/:id_crt', tokenType: 'access' },  \n    toggleArchiveCRT: { url: '/criteria/:id_crt/archive', tokenType: 'access' },  \n    deleteOneCRT: { url: '/criteria/:id_crt', tokenType: 'access' },  \n    getStatsCRT: { url: '/criteria/stats', tokenType: 'access' },  \n}\n```","x":-640,"y":-220,"width":882,"height":900}
	],
	"edges":[
		{"id":"03d650358c96fdda","fromNode":"1de8d33802724917","fromSide":"right","toNode":"740c1a627b1f6030","toSide":"left"},
		{"id":"37ae996aa93eded4","fromNode":"d112876cc0a5712a","fromSide":"left","toNode":"65411924f6c83a84","toSide":"right","fromEnd":"arrow"},
		{"id":"11208c4d9484567a","fromNode":"82694394777ebb31","fromSide":"bottom","toNode":"d112876cc0a5712a","toSide":"top"},
		{"id":"c7980170deb4cf86","fromNode":"82694394777ebb31","fromSide":"left","toNode":"65411924f6c83a84","toSide":"right"},
		{"id":"10718a988e68a353","fromNode":"132d663ac4b20ce3","fromSide":"left","toNode":"d112876cc0a5712a","toSide":"right","fromEnd":"arrow"}
	]
}