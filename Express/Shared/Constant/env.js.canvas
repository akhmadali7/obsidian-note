{
  "edges": [
  ],
  "nodes": [
    {
      "height": 580,
      "id": "3d4e59a5c164409e",
      "styleAttributes": {
      },
      "text": "```js\n// config.js  \nimport dotenv from 'dotenv';  \n  \n// Exporting the values  \nexport const PORT = process.env.PORT || 4000;  \nexport const NODE_ENV = process.env.NODE_ENV || 'development';  \nexport const DB_HOST = process.env.DB_HOST || 'localhost';  \nexport const DB_USER = process.env.DB_USER || 'root';  \nexport const DB_PASSWORD = process.env.DB_PASSWORD || '';  \nexport const DB_NAME = process.env.DB_NAME || 'DSSVikor';  \nexport const BCRYPT_SALT_ROUNDS = process.env.BCRYPT_SALT_ROUNDS || 10;  \n  \nexport const JWT_SECRET_ACCESS_TOKEN = process.env.JWT_SECRET_ACCESS_TOKEN;  \nexport const JWT_SECRET_REFRESH_TOKEN = process.env.JWT_SECRET_REFRESH_TOKEN;  \nexport const JWT_SECRET_EMAIL_VERIFICATION_TOKEN = process.env.JWT_SECRET_EMAIL_VERIFICATION_TOKEN;  \n  \nexport const JWT_ACCESS_TOKEN_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || '30m';  \nexport const JWT_REFRESH_TOKEN_EXPIRES_IN = process.env.JWT_REFRESH_TOKEN_EXPIRES_IN || '30d';  \nexport const JWT_EMAIL_VERIFICATION_EXPIRES_IN = process.env.JWT_EMAIL_VERIFICATION_EXPIRES_IN || '1d';  \n  \nexport const EMAIL_USER = process.env.EMAIL_USER;  \nexport const EMAIL_PASS = process.env.EMAIL_PASS;  \nexport const APP_ORIGIN = process.env.APP_ORIGIN\n```",
      "type": "text",
      "width": 1000,
      "x": 540,
      "y": -240
    },
    {
      "height": 3000,
      "id": "cbe4b35b2d8dde4c",
      "styleAttributes": {
      },
      "text": "The approach of creating a separate **`env.js`** file for managing environment variables (instead of accessing them directly with `process.env` throughout the code) has several key advantages, especially when building production-grade applications. Here are the reasons why this is considered a good practice:\n\n### 1. **Centralized Configuration Management**\n\n- **Single Point of Truth**: By centralizing the configuration values into a single file, you make it easier to manage and modify environment variables. If you need to update a setting, you can do so in the `config.js` file, rather than searching through the codebase for each instance where `process.env` is used.\n    \n- **Organized and Maintainable**: It’s much easier to understand and maintain when all configuration values are located in one place. This keeps the environment configuration decoupled from the business logic.\n    \n\n### 2. **Prevents Direct Access to `process.env`**\n\n- **Encapsulation**: Directly accessing `process.env` all over the codebase makes the environment configuration scattered. If there’s a typo or an inconsistency in the environment variables, it might take longer to debug. With a centralized config file, if something goes wrong, it’s easier to spot the issue in one place.\n    \n- **Type Safety**: By importing values from the configuration file, you can manage types more effectively and ensure that all expected values are available. In TypeScript, for example, this becomes even more useful, as you can type-check configuration values and make sure that your app is working with the correct types.\n    \n\n### 3. **Clear Default Values**\n\n- **Fallback Defaults**: By setting default values in `config.js` (like `4000` for `PORT` or `'development'` for `NODE_ENV`), you ensure that the application behaves in a predictable way even if some environment variables are not set. This makes it easier to test locally without needing to define all environment variables in your `.env` file every time.\n    \n- **Graceful Fallback**: This way, the application doesn’t break if certain variables aren’t defined, and it’s much easier to handle the defaults across the entire app.\n    \n\n### 4. **Simplifies Testing and Development**\n\n- **Easier to Mock in Tests**: When writing unit tests or running the app in a different environment, you can easily mock the configuration in `config.js` without modifying the actual environment variables. This provides flexibility in testing different configurations without relying on environment-specific setups.\n    \n- **Improves Local Development**: During development, you often change configuration values frequently. By having a clear, well-structured config file, it’s easier to modify and reload the app with different settings without directly manipulating environment variables.\n    \n\n### 5. **Improved Security and Error Handling**\n\n- **Avoids Leaking Sensitive Info**: If your environment variables contain sensitive information (e.g., `DB_PASSWORD`, `JWT_SECRET_ACCESS_TOKEN`), directly accessing `process.env` throughout the application can make it harder to control and log which variables are being used and where. By encapsulating this logic, you can ensure sensitive data isn’t inadvertently exposed.\n    \n- **Early Validation and Error Handling**: You can add checks in your `config.js` to ensure that required environment variables are defined. For example, you can throw an error if a variable like `JWT_SECRET_ACCESS_TOKEN` is missing. This makes the application’s configuration more robust by catching misconfigurations early.\n    \n\nExample:\n\n```js\nif (!process.env.JWT_SECRET_ACCESS_TOKEN) {\n    throw new Error(\"Missing JWT_SECRET_ACCESS_TOKEN in environment variables.\");\n}\n```\n\n### 6. **Easier to Scale and Extend**\n\n- **Extensibility**: If you need to add new configuration values later, it's straightforward to update the `config.js` file without having to refactor the entire codebase. You just add new exports for the configuration variables, and the rest of your codebase will have consistent access to them.\n    \n- **Multiple Environments**: You can have multiple `.env` files for different environments (e.g., `.env`, `.env.test`, `.env.production`), and this `config.js` approach allows you to maintain a unified structure that works across all environments.\n    \n\n### 7. **Better Documentation for Configuration**\n\n- **Clear and Descriptive Configuration**: By creating descriptive variable names (like `JWT_SECRET_ACCESS_TOKEN` or `DB_HOST`), and possibly adding some comments within the `config.js` file, you can document the expected environment variables for your project. This makes it clear what each environment variable is used for, especially for new developers who might be unfamiliar with the project.\n    \n\n### Example: Improved Config File\n\nHere's an enhanced version of `config.js` with validation and comments:\n\n```js\n// config.js\nimport dotenv from 'dotenv';\n\ndotenv.config(); // Load environment variables from .env file\n\n// Check for required environment variables\nif (!process.env.JWT_SECRET_ACCESS_TOKEN) {\n    throw new Error(\"Missing JWT_SECRET_ACCESS_TOKEN in environment variables.\");\n}\n\n// Exporting values\nexport const PORT = process.env.PORT || 4000;\nexport const NODE_ENV = process.env.NODE_ENV || 'development';\nexport const DB_HOST = process.env.DB_HOST || 'localhost';\nexport const DB_USER = process.env.DB_USER || 'root';\nexport const DB_PASSWORD = process.env.DB_PASSWORD || '';\nexport const DB_NAME = process.env.DB_NAME || 'DSSVikor';\nexport const BCRYPT_SALT_ROUNDS = process.env.BCRYPT_SALT_ROUNDS || 10;\n\nexport const JWT_SECRET_ACCESS_TOKEN = process.env.JWT_SECRET_ACCESS_TOKEN;\nexport const JWT_SECRET_REFRESH_TOKEN = process.env.JWT_SECRET_REFRESH_TOKEN;\nexport const JWT_SECRET_EMAIL_VERIFICATION_TOKEN = process.env.JWT_SECRET_EMAIL_VERIFICATION_TOKEN;\n\nexport const JWT_ACCESS_TOKEN_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || '30m';\nexport const JWT_REFRESH_TOKEN_EXPIRES_IN = process.env.JWT_REFRESH_TOKEN_EXPIRES_IN || '30d';\nexport const JWT_EMAIL_VERIFICATION_EXPIRES_IN = process.env.JWT_EMAIL_VERIFICATION_EXPIRES_IN || '1d';\n\nexport const EMAIL_USER = process.env.EMAIL_USER;\nexport const EMAIL_PASS = process.env.EMAIL_PASS;\nexport const APP_ORIGIN = process.env.APP_ORIGIN;\n```\n\n### Summary of Benefits:\n\n- **Centralized configuration management** makes it easier to maintain, update, and access environment variables.\n    \n- **Prevents direct access to `process.env`** in the rest of the codebase, reducing errors and making code more readable.\n    \n- **Improves testability**, security, and extensibility, especially in production systems.\n    \n- **Adds early validation** and improves error handling by checking for missing or incorrect environment variables.\n    \n\nBy keeping configuration management in a single place (`config.js`), you make your app more organized, scalable, and easier to maintain. This also helps reduce bugs caused by incorrectly set or missing environment variables.",
      "type": "text",
      "width": 960,
      "x": -940,
      "y": -940
    }
  ]
}